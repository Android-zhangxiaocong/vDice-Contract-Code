pragma solidity ^0.4.10;

import "github.com/oraclize/ethereum-api/oraclizeAPI.sol";
import "github.com/dapphub/ds-math/src/math.sol";

contract Owned {
    address public owner;
    
    modifier onlyOwner {
        if (msg.sender != owner) revert();
        _;
    }
    
    function Owned() {
        owner = msg.sender;
    }
}

contract oraclizeSettings is Owned {
	uint constant ORACLIZE_PER_SPIN_GAS_LIMIT = 33000;
	uint constant ORACLIZE_BASE_GAS_LIMIT = 150000;
	uint safeGas = 9000;
	
	event newGasLimit(uint _gasLimit);

	modifier onlyIfValidGas(uint _limit) {
	    if (ORACLIZE_BASE_GAS_LIMIT + safeGas < ORACLIZE_BASE_GAS_LIMIT) revert();
	    if (safeGas > 25000) revert();
	    _;
	}

	function setSafeGas(uint _gas) 
		onlyOwner 
		onlyIfValidGas(_gas)
	{
		safeGas = _gas;
		newGasLimit(_gas);
	}	
}


contract HouseManaged is Owned {
    
    address public houseAddress;
    bool public isStopped;

    event LOG_ContractStopped();
    event LOG_ContractResumed();
    event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress);
    event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress);
    
    modifier onlyIfNotStopped {
        if (isStopped) revert();
        _;
    }

    modifier onlyIfStopped {
        if (!isStopped) revert();
        _;
    }
    
    function HouseManaged() {
        houseAddress = msg.sender;
    }

    function stopContract()
        onlyOwner {

        isStopped = true;
        LOG_ContractStopped();
    }

    function resumeContract()
        onlyOwner {

        isStopped = false;
        LOG_ContractResumed();
    }

    function changeHouseAddress(address newHouse)
        onlyOwner {

        if (newHouse == address(0x0)) revert();
        houseAddress = newHouse;
        LOG_HouseAddressChanged(houseAddress, newHouse);
    }

    function changeOwnerAddress(address newOwner)
        onlyOwner {

        if (newOwner == address(0x0)) revert();
        owner = newOwner;
        LOG_OwnerAddressChanged(owner, newOwner);
    }
    
}


contract usingInvestorsModule is HouseManaged, oraclizeSettings {
    
    uint constant MAX_INVESTORS = 5; //maximum number of investors
    uint constant divestFee = 50; //divest fee percentage (10000 = 100%)

     struct Investor {
        address investorAddress;
        uint amountInvested;
        bool votedForEmergencyWithdrawal;
    }
    
    //Starting at 1
    mapping(address => uint) public investorIDs;
    mapping(uint => Investor) public investors;
    uint public numInvestors = 0;

    uint public invested = 0;
    
    uint public investorsProfit = 0;
    uint public investorsLosses = 0;
    bool profitDistributed;
    
    event LOG_InvestorEntrance(address investor, uint amount);
    event LOG_InvestorCapitalUpdate(address investor, int amount);
    event LOG_InvestorExit(address investor, uint amount);
    event LOG_EmergencyAutoStop();
    
    event LOG_ZeroSend();
    event LOG_ValueIsTooBig();
    event LOG_FailedSend(address addr, uint value);
    event LOG_SuccessfulSend(address addr, uint value);
    


    modifier onlyMoreThanMinInvestment {
        if (msg.value <= getMinInvestment()) revert();
        _;
    }

    modifier onlyMoreThanZero {
        if (msg.value == 0) revert();
        _;
    }

    
    modifier onlyInvestors {
        if (investorIDs[msg.sender] == 0) revert();
        _;
    }

    modifier onlyNotInvestors {
        if (investorIDs[msg.sender] != 0) revert();
        _;
    }
    
    modifier investorsInvariant {
        _;
        if (numInvestors > MAX_INVESTORS) revert();
    }
    
    modifier onlyIfProfitNotDistributed {
        if (!profitDistributed) {
            _;
        }
    }
    
    function getBankroll()
        constant
        returns(uint) {

        if ((invested < investorsProfit) ||
            (invested + investorsProfit < invested) ||
            (invested + investorsProfit < investorsLosses)) {
            return 0;
        }
        else {
            return invested + investorsProfit - investorsLosses;
        }
    }

    function getMinInvestment()
        constant
        returns(uint) {

        if (numInvestors == MAX_INVESTORS) {
            uint investorID = searchSmallestInvestor();
            return getBalance(investors[investorID].investorAddress);
        }
        else {
            return 0;
        }
    }

    function getLossesShare(address currentInvestor)
        constant
        returns (uint) {

        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested;
    }

    function getProfitShare(address currentInvestor)
        constant
        returns (uint) {

        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;
    }

    function getBalance(address currentInvestor)
        constant
        returns (uint) {

        uint invested = investors[investorIDs[currentInvestor]].amountInvested;
        uint profit = getProfitShare(currentInvestor);
        uint losses = getLossesShare(currentInvestor);

        if ((invested + profit < profit) ||
            (invested + profit < invested) ||
            (invested + profit < losses))
            return 0;
        else
            return invested + profit - losses;
    }

    function searchSmallestInvestor()
        constant
        returns(uint) {

        uint investorID = 1;
        for (uint i = 1; i <= numInvestors; i++) {
            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {
                investorID = i;
            }
        }

        return investorID;
    }

    
    function addInvestorAtID(uint id)
        private {

        investorIDs[msg.sender] = id;
        investors[id].investorAddress = msg.sender;
        investors[id].amountInvested = msg.value;
        invested += msg.value;

        LOG_InvestorEntrance(msg.sender, msg.value);
    }

    function profitDistribution()
        private
        onlyIfProfitNotDistributed {

        uint copyInvested;

        for (uint i = 1; i <= numInvestors; i++) {
            address currentInvestor = investors[i].investorAddress;
            uint profitOfInvestor = getProfitShare(currentInvestor);
            uint lossesOfInvestor = getLossesShare(currentInvestor);
            //Check for overflow and underflow
            if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) &&
                (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  {
                investors[i].amountInvested += profitOfInvestor - lossesOfInvestor;
                LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor));
            }
            else {
                isStopped = true;
                LOG_EmergencyAutoStop();
            }

            if (copyInvested + investors[i].amountInvested >= copyInvested)
                copyInvested += investors[i].amountInvested;
        }

        delete investorsProfit;
        delete investorsLosses;
        invested = copyInvested;

        profitDistributed = true;
    }
    
    function increaseInvestment()
        payable
        onlyIfNotStopped
        onlyMoreThanZero
        onlyInvestors  {

        profitDistribution();
        investors[investorIDs[msg.sender]].amountInvested += msg.value;
        invested += msg.value;
    }

    function newInvestor()
        payable
        onlyIfNotStopped
        onlyMoreThanZero
        onlyNotInvestors
        onlyMoreThanMinInvestment
        investorsInvariant {

        profitDistribution();

        if (numInvestors == MAX_INVESTORS) {
            uint smallestInvestorID = searchSmallestInvestor();
            divest(investors[smallestInvestorID].investorAddress);
        }

        numInvestors++;
        addInvestorAtID(numInvestors);
    }

    function divest()
        onlyInvestors {

        divest(msg.sender);
    }


    function divest(address currentInvestor)
        private
        investorsInvariant {

        profitDistribution();
        uint currentID = investorIDs[currentInvestor];
        uint amountToReturn = getBalance(currentInvestor);

        if ((invested >= investors[currentID].amountInvested)) {
            invested -= investors[currentID].amountInvested;
            uint divestFeeAmount =  (amountToReturn*divestFee)/10000;
            amountToReturn -= divestFeeAmount;

            delete investors[currentID];
            delete investorIDs[currentInvestor];

            //Reorder investors
            if (currentID != numInvestors) {
                // Get last investor
                Investor lastInvestor = investors[numInvestors];
                //Set last investor ID to investorID of divesting account
                investorIDs[lastInvestor.investorAddress] = currentID;
                //Copy investor at the new position in the mapping
                investors[currentID] = lastInvestor;
                //Delete old position in the mappping
                delete investors[numInvestors];
            }

            numInvestors--;
            safeSend(currentInvestor, amountToReturn);
            safeSend(houseAddress, divestFeeAmount);
            LOG_InvestorExit(currentInvestor, amountToReturn);
        } else {
            isStopped = true;
            LOG_EmergencyAutoStop();
        }
    }
    
    function forceDivest(address _investorAddress) 
        onlyOwner
        onlyIfStopped {
            divest(_investorAddress);
    }

    function forceDivestOfAllInvestors()
        onlyOwner {

        uint copyNumInvestors = numInvestors;
        for (uint i = 1; i <= copyNumInvestors; i++) {
            divest(investors[1].investorAddress);
        }
    }
    
    function safeSend(address addr, uint value)
        private {

        if (value == 0) {
            LOG_ZeroSend();
            return;
        }

        if (this.balance < value) {
            LOG_ValueIsTooBig();
            return;
        }

        if (!(addr.call.gas(safeGas).value(value)())) {
            LOG_FailedSend(addr, value);
            if (addr != houseAddress) {
                //Forward to house address all change
                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);
            }
        }

        LOG_SuccessfulSend(addr,value);
    }
}


contract EmergencyWithdrawalModule is usingInvestorsModule {
    uint constant EMERGENCY_WITHDRAWAL_RATIO = 80; //ratio percentage (100 = 100%)
    uint constant EMERGENCY_TIMEOUT = 3 days;
    
    struct WithdrawalProposal {
        address toAddress;
        uint atTime;
    }
    
    WithdrawalProposal public proposedWithdrawal;
    
    event LOG_EmergencyWithdrawalProposed();
    event LOG_EmergencyWithdrawalFailed(address withdrawalAddress);
    event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);
    event LOG_EmergencyWithdrawalVote(address investor, bool vote);
    
    modifier onlyAfterProposed {
        if (proposedWithdrawal.toAddress == 0) revert();
        _;
    }
    
    modifier onlyIfEmergencyTimeOutHasPassed {
        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) revert();
        _;
    }
    
    function voteEmergencyWithdrawal(bool vote)
        onlyInvestors
        onlyAfterProposed
        onlyIfStopped {

        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;
        LOG_EmergencyWithdrawalVote(msg.sender, vote);
    }

    function proposeEmergencyWithdrawal(address withdrawalAddress)
        onlyIfStopped
        onlyOwner {

        //Resets previous votes
        for (uint i = 1; i <= numInvestors; i++) {
            delete investors[i].votedForEmergencyWithdrawal;
        }

        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);
        LOG_EmergencyWithdrawalProposed();
    }

    function executeEmergencyWithdrawal()
        onlyOwner
        onlyAfterProposed
        onlyIfStopped
        onlyIfEmergencyTimeOutHasPassed {

        uint numOfVotesInFavour;
        uint amountToWithdraw = this.balance;

        for (uint i = 1; i <= numInvestors; i++) {
            if (investors[i].votedForEmergencyWithdrawal == true) {
                numOfVotesInFavour++;
                delete investors[i].votedForEmergencyWithdrawal;
            }
        }

        if (numOfVotesInFavour >= EMERGENCY_WITHDRAWAL_RATIO * numInvestors / 100) {
            if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) {
                LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);
            }
            else {
                LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw);
            }
        }
        else {
            revert();
        }
    }
    
        /*
    The owner can use this function to force the exit of an investor from the
    contract during an emergency withdrawal in the following situations:
        - Unresponsive investor
        - Investor demanding to be paid in other to vote, the facto-blackmailing
        other investors
    */
    function forceDivestOfOneInvestor(address currentInvestor)
        onlyOwner
        onlyIfStopped {

        forceDivest(currentInvestor);
        //Resets emergency withdrawal proposal. Investors must vote again
        delete proposedWithdrawal;
    }
}

contract Slot is usingOraclize, EmergencyWithdrawalModule, DSMath {
    
    uint constant INVESTORS_EDGE_MAX = 200; 
    uint constant HOUSE_EDGE_MAX = 50;
    uint constant CAPITAL_RISK_MAX = 250;
    
    uint constant MAX_SPINS = 16;
    
    uint investorsEdge;
    uint houseEdge;
    uint capitalRisk;
    uint minBet;
 
    struct SpinsContainer {
        address playerAddress;
        bool processed;
        uint nSpins;
        uint amountWagered;
        uint[] spinResult;
        uint payout;
    }
    
    mapping (bytes32 => SpinsContainer) spins;
    
    /* Both arrays are ordered:
     - probabilities are ordered from smallest to highest
     - multipliers are ordered from highest to lowest
     The probabilities are expressed as integer numbers over a scale of 10000: i.e
     100 is equivalent to 1%, 5000 to 50% and so on.
    */
    uint[] public probabilities;
    uint[] public multipliers;
    
    uint public totalAmountWagered; 
    uint public totalPayoutToPlayers;
    
    event LOG_newSpinsContainer(bytes32 myid, address playerAddress, uint amountWagered, uint nSpins);
    event LOG_SpinExecuted(address playerAddress, uint spinIndex, uint numberDrawn);
    event LOG_SpinsContainerInfo(address playerAddress, uint netPayout);
    
    function Slot() payable oraclizeAPI {
        investorsEdge = INVESTORS_EDGE_MAX ;
        houseEdge = HOUSE_EDGE_MAX;
        capitalRisk = CAPITAL_RISK_MAX;
        minBet = 1 wei;
        
        probabilities.push(100);
        probabilities.push(400);
        probabilities.push(1000);
        probabilities.push(2000);
        
        multipliers.push(20);
        multipliers.push(10);
        multipliers.push(2);
        multipliers.push(1);
    }

    //SECTION I: MODIFIERS AND HELPER FUNCTIONS

    modifier onlyOraclize {
        if (msg.sender != oraclize_cbAddress()) revert();
        _;
    }

    modifier onlyIfSpinsExist(bytes32 myid) {
        if(spins[myid].playerAddress == address(0x0)) revert();
        _;
    }
    
    modifier onlyIfNotProcessed(bytes32 myid) {
        if (spins[myid].processed) revert();
        _;
    }
    
    
    function isValidSize(uint _amountWagered) 
        constant 
        returns(bool) {
            
        uint netPotentialPayout = (_amountWagered * (10000 - investorsEdge) * multipliers[0])/ 10000; 
        uint maxAllowedPayout = (capitalRisk * getBankroll())/10000;
        
        return ((netPotentialPayout <= maxAllowedPayout) && (_amountWagered >= minBet));
    }

    modifier onlyIfEnoughFunds(bytes32 myid) {
        if (isValidSize(spins[myid].amountWagered)) {
             _;
        }
        else {
            spins[myid].processed = true;
            safeSend(spins[myid].playerAddress, spins[myid].amountWagered);
            return;
        }
    }
    
	modifier onlyLessThanMaxSpins (uint _nSpins) {
        if (_nSpins > MAX_SPINS) revert();
        _;
    }
    
    /*
        For the game to be fair, the total gross payout over a large number of 
        individual slot spins should be the total amount wagered by the player. 
        
        The game owner, called house, and the investors will gain by applying 
        a small fee, called edge, to the amount won by the player in the case of
        a successful spin. 
        
        The total gross expected payout is equal to the sum of all payout. Each 
        i-th payout is calculated:
                    amountWagered * multipliers[i] * probabilities[i] 
        The resulting equation is:
                    sum of aW * m[i] * p[i] = aW
        After having simplified the equation:
                        sum of m[i] * p[i] = 1
        Since our probabilities are defined over 10000, the sum should be 10000.
        
        The contract owner can modify the multipliers and probabilities array, 
        but the  modifier enforces that the number choosen always result in a 
        fare game.
    */
    modifier onlyIfFair(uint[] _prob, uint[] _payouts) {
        if (_prob.length != _payouts.length) revert();
        uint sum = 0;
        for (uint i = 0; i <_prob.length; i++) {
            sum += _prob[i] * _payouts[i];     
        }
        if (sum != 10000) revert();
        _;
    }

    function()
        payable {
        buySpins(1);
    }

    function buySpins(uint _nSpins) 
        payable 
        onlyLessThanMaxSpins(_nSpins) 
		onlyIfNotStopped {
            
        uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;
        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice("WolframAlpha", gas);
        
        // Disallow bets that even when maximally winning are a loss for player 
        // due to oraclizeFee
        if (oraclizeFee/multipliers[0] + oraclizeFee >= msg.value) revert();
        
        uint amountWagered = msg.value - oraclizeFee;
        uint maxNetPotentialPayout = (amountWagered * (10000 - investorsEdge) * multipliers[0])/10000; 
        uint maxAllowedPayout = (capitalRisk * getBankroll())/10000;
        
        if ((maxNetPotentialPayout <= maxAllowedPayout) && (amountWagered >= minBet)) {
            bytes32 queryId = oraclize_query("WolframAlpha", "A random number between 0 and 2**256");
            uint[] memory results;
             spins[queryId] = 
                SpinsContainer(msg.sender,
                                    false, 
                                    _nSpins,
                                    amountWagered, 
                                    results,
                                    0
                                );
            
            LOG_newSpinsContainer(queryId, msg.sender, amountWagered, _nSpins);
            totalAmountWagered += amountWagered;
        } else {
            revert();
        }
    }
    
    function executeSpins(bytes32 myid, bytes randomBytes) 
        private 
        returns(uint)
    {
        uint amountWon = 0;
        uint numberDrawn = 0;
        uint rangeUpperEnd = 0;
        uint nSpins = spins[myid].nSpins;
        
        
        for (uint i = 0; i < 2*nSpins; i += 2) {
            // A number between 0 and 2**16, normalized over 0 - 10000
            numberDrawn = ((uint(randomBytes[i])*256 + uint(randomBytes[i+1]))*10000)/2**16;
            rangeUpperEnd = 0;
            spins[myid].spinResult.push(numberDrawn);
            LOG_SpinExecuted(spins[myid].playerAddress, i/2, numberDrawn);
            for (uint j = 0; j < probabilities.length; j++) {
                rangeUpperEnd += probabilities[j];
                if (numberDrawn < rangeUpperEnd) {
                    amountWon += (spins[myid].amountWagered * multipliers[j]) / nSpins;
                    break;
                }
            }
        }
        return amountWon;
    }
    
    function __callback(bytes32 myid, string result)
        onlyOraclize
        onlyIfSpinsExist(myid)
        onlyIfNotProcessed(myid)
        onlyIfEnoughFunds(myid)
    {
		
        spins[myid].processed = true;
        uint payout = executeSpins(myid, bytes(result));
        
        if (payout >= spins[myid].amountWagered) {
            investorsLosses += sub(payout, spins[myid].amountWagered);
            payout = (payout*(10000 - investorsEdge))/10000;
        }
        else {
            uint tempProfit = add(investorsProfit, sub(spins[myid].amountWagered, payout));
            investorsProfit += (sub(spins[myid].amountWagered, payout)*(10000 - houseEdge))/10000;
            safeSend(houseAddress, sub(tempProfit,investorsProfit));
        }
        
        spins[myid].payout = payout;
        LOG_SpinsContainerInfo(spins[myid].playerAddress, payout);
        safeSend(spins[myid].playerAddress, payout);
        totalPayoutToPlayers += payout;
        
        delete profitDistributed;

    }
    
    // SETTERS - SETTINGS ACCESSIBLE BY OWNER
    
    // Check ordering as well, since ordering assumptions are made in _callback 
    // and elsewhere
    function setPayouts(uint[] _probabilities, uint[] _multipliers) 
        onlyOwner 
        onlyIfFair(_probabilities, _multipliers) {
            
        delete probabilities;
        delete multipliers;
        
        uint lastProbability = 0;
        uint lastMultiplier = 2**256 - 1;
        
        for (uint i = 0; i < _probabilities.length; i++) {
            probabilities.push(_probabilities[i]);
            if (lastProbability >= _probabilities[i]) revert();
            lastProbability = _probabilities[i];
        }
        
        for (i = 0; i < _multipliers.length; i++) {
            multipliers.push(_multipliers[i]);
            if (lastMultiplier <= _multipliers[i]) revert();
            lastMultiplier = _multipliers[i];
        }
    }
    
    function setHouseEdge(uint _houseEdge) onlyOwner {
        if ( _houseEdge > HOUSE_EDGE_MAX) revert();
        houseEdge = _houseEdge;
    }
    
    function setInvestorsEdge(uint _investorsEdge) onlyOwner {
        if ( _investorsEdge > INVESTORS_EDGE_MAX) revert();
        investorsEdge = _investorsEdge;
    }
    
    function setCapitalRisk(uint _capitalRisk) onlyOwner {
        if ( _capitalRisk > CAPITAL_RISK_MAX ) revert();
        capitalRisk = _capitalRisk;
    }
    
    function setMinBet(uint _minBet) onlyOwner {
        minBet = _minBet;
    }
    

    // GETTERS - CONSTANT METHODS
    
    function getSpinsContainer(bytes32 myid)
        constant
        returns(address, bool, uint, uint, uint[]) {
        return (spins[myid].playerAddress, spins[myid].processed, spins[myid].amountWagered, spins[myid].payout, spins[myid].spinResult); 
    }

    // Returns minimal amount to wager to return a profit in case of max win
    function getMinAmountToWager(uint _nSpins)
        onlyLessThanMaxSpins(_nSpins)
        constant
		returns(uint) {
        uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;
        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice("WolframAlpha", gas);
        return minBet + oraclizeFee/multipliers[0] + oraclizeFee;
    }
   
	function getOraclizeFee(uint _nSpins) 
	    onlyLessThanMaxSpins(_nSpins)
		constant 
		returns(uint) {
	
        uint gas = _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas;
        return OraclizeI(OAR.getAddress()).getPrice("WolframAlpha", gas);
	} 

    function getMaxAmountToWager(uint _nSpins)
        onlyLessThanMaxSpins(_nSpins)
        constant
        returns(uint) {

        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice("WolframAlpha", _nSpins*ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas);
        uint maxWage =  (capitalRisk * getBankroll())*10000/((10000 - investorsEdge)*10000*multipliers[0]);
        return maxWage + oraclizeFee;
    }
    
    function getContractParams() constant returns(uint[4]) {
        return [investorsEdge, houseEdge, capitalRisk, minBet];
    }
    
    function safeSend(address addr, uint value)
        private {

        if (value == 0) {
            LOG_ZeroSend();
            return;
        }

        if (this.balance < value) {
            LOG_ValueIsTooBig();
            return;
        }

        if (!(addr.call.gas(safeGas).value(value)())) {
            LOG_FailedSend(addr, value);
            if (addr != houseAddress) {
                //Forward to house address all change
                if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value);
            }
        }

        LOG_SuccessfulSend(addr,value);
    }
}



